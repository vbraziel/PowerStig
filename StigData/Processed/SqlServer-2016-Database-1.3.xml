<DISASTIG id="MS_SQL_Server_2016_Database_STIG" version="1.3" created="11/6/2018">
  <DocumentRule dscresourcemodule="None">
    <Rule id="V-79061" severity="medium" conversionstatus="pass" title="SRG-APP-000023-DB-000001" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Determine if SQL Server is configured to allow the use of contained databases.

In the Object Explorer in SQL Server Management Studio (SSMS), Right-click on the server instance &gt;&gt; Select "Properties" &gt;&gt; Select the Advanced page

If "Enabled Contained Databases" is "False", this is not a finding. 

OR

In a query interface such as the SSMS Transact-SQL editor, run the statement:
EXEC sp_configure 'contained database authentication'

If the returned value in the "config_value" and/or "run_value" column is 0, this is not a finding.

Determine whether SQL Server is configured to use only Windows authentication. 

In the Object Explorer in SQL Server Management Studio (SSMS), right-click on the server instance; select "Properties". Select the Security page. If Windows Authentication Mode is selected, this is not a finding. 

OR

In a query interface such as the SSMS Transact-SQL editor, run the statement: 

SELECT CASE SERVERPROPERTY('IsIntegratedSecurityOnly')   
 WHEN 1 THEN 'Windows Authentication'   
 WHEN 0 THEN 'Windows and SQL Server Authentication'   
END as [Authentication Mode] 

If the returned value in the "Authentication Mode" column is "Windows Authentication", this is not a finding. 

Mixed mode (both SQL Server authentication and Windows authentication) is in use. If the need for mixed mode has not been documented and approved, this is a finding. 

From the documentation, obtain the list of accounts authorized to be managed by SQL Server. 

Determine the accounts (SQL Logins) actually managed by SQL Server. Run the statement: 

SELECT name
FROM sys.database_principals
WHERE type_desc = 'SQL_USER'
AND authentication_type_desc = 'DATABASE'; 

If any accounts listed by the query are not listed in the documentation, this is a finding.

Risk must be accepted by the ISSO/ISSM.</RawString>
    </Rule>
    <Rule id="V-79069" severity="low" conversionstatus="pass" title="SRG-APP-000080-DB-000063" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Check the server documentation to determine if collecting and keeping historical versions of a table is required. If not, this is not a finding.

Find all of the temporal tables in the database using the following query:

SELECT SCHEMA_NAME(T.schema_id) AS schema_name, T.name AS table_name, T.temporal_type_desc,
  SCHEMA_NAME(H.schema_id) + '.' + H.name AS history_table
FROM sys.tables T
JOIN sys.tables H ON T.history_table_id = H.object_id
WHERE T.temporal_type != 0
ORDER BY schema_name, table_name 

Using the system documentation, determine which tables are required to be temporal tables. If any tables listed in the documentation are not in the above list, this is a finding.

Ensure a field exists documenting the login and/or user who last modified the record. If this does not exist, this is a finding.

Review the system documentation to determine the history retention period. 
Navigate to the table in Object Explorer &gt;&gt; Right-click on the table and select Script Table As &gt;&gt; CREATE To &gt;&gt; New Query Editor Window

Locate the line that contains "SYSTEM_VERSIONING".
Locate the text that states "HISTORY_RETENTION_PERIOD".

If this text is missing, or is set to a value less than the documented history retention period, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79071" severity="high" conversionstatus="pass" title="SRG-APP-000080-DB-000063" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Determine if the trustworthy property is set on the database.

SELECT name as DatabaseName,
SUSER_SNAME(owner_sid) AS DatabaseOwner, is_trustworthy_on
FROM sys.databases

If trustworthy is not enabled, this is not a finding.

If the database is MSDB, trustworthy is required to be enabled and therefore, this is not a finding.

If trustworthy is enabled, determine if the database owner is a privileged account.

DECLARE @databaseOwner AS nvarchar(50)
SET @databaseOwner = 'sa'

SELECT member.name AS Login, role.name AS Role
FROM sys.server_principals member
INNER JOIN sys.server_role_members rm ON member.principal_id = rm.member_principal_id
INNER JOIN sys.server_principals role ON rm.role_principal_id = role.principal_id
WHERE member.name = @databaseOwner
 AND role.name IN ('sysadmin','securityadmin')

SELECT login.name, permission.permission_name
FROM sys.server_principals login
INNER JOIN sys.server_permissions permission ON login.principal_id = permission.grantee_principal_id
WHERE login.name = @databaseOwner
 AND permission.permission_name IN ('CONTROL SERVER')

If the database owner is a privileged account, this is a finding.

If the database owner is not a privileged account, review the system documentation to determine if the trustworthy property is required and authorized. If this is not documented, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79073" severity="medium" conversionstatus="pass" title="SRG-APP-000090-DB-000065" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Obtain the list of approved audit maintainers from the system documentation.

Review the database roles and individual users that have the following role memberships, all of which enable the ability to create and maintain audit specifications.

db_owner

Review the database roles and individual users that have the following permissions, all of which enable the ability to create and maintain audit definitions.

ALTER ANY DATABASE AUDIT
CONTROL
 
Use the following query to determine the roles and users that have the listed permissions:

SELECT DP.Name AS 'Database Principal', DbPerm.permission_name AS 'Granted Permission', R.name AS 'Role'
FROM sys.database_principals DP
LEFT OUTER JOIN sys.database_permissions DbPerm ON DP.principal_id = DbPerm.grantee_principal_id
LEFT OUTER JOIN sys.database_role_members DRM ON DP.principal_id = DRM.member_principal_id
INNER JOIN sys.database_principals R ON DRM.role_principal_id = R.principal_id
WHERE DbPerm.permission_name IN ('CONTROL','ALTER ANY DATABASE AUDIT')
 OR R.name IN ('db_owner')

If any of the roles or users returned have permissions that are not documented, or the documented audit maintainers do not have permissions, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79075" severity="medium" conversionstatus="pass" title="SRG-APP-000133-DB-000179" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Obtain a listing of users and roles who are authorized to change stored procedures, functions, and triggers from the server documentation.

In each user database, execute the following query:

SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc,
  CASE class
   WHEN 0 THEN DB_NAME()
   WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id)
   WHEN 3 THEN SCHEMA_NAME(major_id)
    ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')'
   END AS securable_name, DP.state_desc, DP.permission_name
FROM sys.database_permissions DP
JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id
LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','','RF','PC','IF','FN','TF','U')
WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53)

SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name
FROM sys.database_principals R
JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id
JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id
WHERE R.name IN ('db ddladmin','db_owner')
   AND M.name != 'dbo'

If any users or role permissions returned are not authorized to modify the specified object or type, this is a finding.

If any user or role membership is not authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79077" severity="medium" conversionstatus="pass" title="SRG-APP-000133-DB-000179" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Obtain a listing of schema ownership from the server documentation.

Execute the following query to obtain a current listing of schema ownership.

SELECT S.name AS schema_name, P.name AS owning_principal
FROM sys.schemas S
JOIN sys.database_principals P ON S.principal_id = P.principal_id
ORDER BY schema_name

If any schema is owned by an unauthorized database principal, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79079" severity="medium" conversionstatus="pass" title="SRG-APP-000133-DB-000200" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review system documentation to identify SQL Server accounts authorized to own database objects. 

If the SQL Server database ownership list does not exist or needs to be updated, this is a finding. 

The following query can be of use in making this determination: 

;with objects_cte as
(SELECT o.name, o.type_desc,
   CASE
    WHEN o.principal_id is null then s.principal_id
     ELSE o.principal_id
    END as principal_id
 FROM sys.objects o
 INNER JOIN sys.schemas s
 ON o.schema_id = s.schema_id
 WHERE o.is_ms_shipped = 0
)
SELECT cte.name, cte.type_desc, dp.name as ObjectOwner 
FROM objects_cte cte
INNER JOIN sys.database_principals dp
ON cte.principal_id = dp.principal_id
ORDER BY dp.name, cte.name

If any of the listed owners is not authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79081" severity="medium" conversionstatus="pass" title="SRG-APP-000133-DB-000362" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Obtain a listing of users and roles who are authorized to modify database structure and logic modules from the server documentation.

Execute the following query:
SELECT P.type_desc AS principal_type, P.name AS principal_name, O.type_desc,
   CASE class
    WHEN 0 THEN DB_NAME()
    WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id)
    WHEN 3 THEN SCHEMA_NAME(major_id)
      ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')'
   END AS securable_name, DP.state_desc, DP.permission_name
FROM sys.database_permissions DP
JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id
LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U')
WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53)

SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name
FROM sys.database_principals R
JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id
JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id
WHERE R.name IN ('db_ddladmin','db_owner')
AND M.name != 'dbo'

If any users or role permissions returned are not authorized to modify the specified object or type, this is a finding.

If any user or role membership is not authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79083" severity="medium" conversionstatus="pass" title="SRG-APP-000226-DB-000147" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review the system security plan (SSP) to determine whether the database is static, the recovery model to be used, the backup schedule, and the plan for testing database restoration.

If the SSP does not state that the database is static, assume that it is not static. If any of the other information is absent, this is a finding. 

If the database is not static, and the documented recovery model is Bulk Logged, but the justification and authorization for this are not documented, this is a finding. 

Run the following to determine Recovery Model:

USE [master]
GO

SELECT name, recovery_model_desc
FROM sys.databases
ORDER BY name

If the recovery model description does not match the documented recovery model, this is a finding. 

Review the jobs set up to implement the backup plan. If they are absent, this is a finding. 

Check the history of the backups by running the following query.  It checks the last 30 days of backups by database.
USE [msdb]
GO

SELECT database_name, 
   CASE type
    WHEN 'D' THEN 'Full'
    WHEN 'I' THEN 'Differential'
    WHEN 'L' THEN 'Log'
   ELSE type
   END AS backup_type,
 is_copy_only,
 backup_start_date, backup_finish_date
FROM dbo.backupset
WHERE backup_start_date &gt;= dateadd(day, - 30, getdate()) 
ORDER BY database_name, backup_start_date DESC

If the history indicates a pattern of job failures by missing or gaps in backups, this is a finding. 

Review evidence that database recovery is tested annually or more often, and that the most recent test was successful. If not, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79095" severity="medium" conversionstatus="pass" title="SRG-APP-000251-DB-000160" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review DBMS code (stored procedures, functions, triggers), application code, settings, column and field definitions, and constraints to determine whether the database is protected against invalid input. 

If code exists that allows invalid data to be acted upon or input into the database, this is a finding. 

If column/field definitions are not reflective of the data, this is a finding. 

If columns/fields do not contain constraints and validity checking where required, this is a finding. 

Where a column/field is noted in the system documentation as necessarily free-form, even though its name and context suggest that it should be strongly typed and constrained, the absence of these protections is not a finding. 

Where a column/field is clearly identified by name, caption or context as Notes, Comments, Description, Text, etc., the absence of these protections is not a finding.</RawString>
    </Rule>
    <Rule id="V-79105" severity="low" conversionstatus="pass" title="SRG-APP-000328-DB-000301" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review system documentation to determine requirements for object ownership and authorization delegation.

Use the following query to discover database object ownership:

Schemas not owned by the schema or dbo:

SELECT name AS schema_name, USER_NAME(principal_id) AS schema_owner
FROM sys.schemas
WHERE schema_id != principal_id
 AND principal_id != 1

Objects owned by an individual principal:

SELECT object_id, name AS securable, 
  USER_NAME(principal_id) AS object_owner,
  type_desc
FROM sys.objects
WHERE is_ms_shipped = 0 AND principal_id IS NOT NULL
ORDER BY type_desc, securable, object_owner

Use the following query to discover database users who have been delegated the right to assign additional permissions:

SELECT U.type_desc, U.name AS grantee,
 DP.class_desc AS securable_type,
   CASE DP.class
    WHEN 0 THEN DB_NAME()
    WHEN 1 THEN OBJECT_NAME(DP.major_id) 
    WHEN 3 THEN SCHEMA_NAME(DP.major_id)
   ELSE CAST(DP.major_id AS nvarchar)
   END AS securable,
       permission_name, state_desc
FROM sys.database_permissions DP
JOIN sys.database_principals U ON DP.grantee_principal_id = U.principal_id
WHERE DP.state = 'W'
ORDER BY grantee, securable_type, securable

If any of these rights are not documented and authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79107" severity="medium" conversionstatus="pass" title="SRG-APP-000342-DB-000302" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review the system documentation to obtain a listing of stored procedures and functions that utilize impersonation. Execute the following query:

SELECT S.name AS schema_name, O.name AS module_name,
  USER_NAME(
      CASE M.execute_as_principal_id
       WHEN -2 THEN COALESCE(O.principal_id, S.principal_id)
      ELSE M.execute_as_principal_id
      END
  ) AS execute_as
FROM sys.sql_modules M
JOIN sys.objects O ON M.object_id = O.object_id
JOIN sys.schemas S ON O.schema_id = S.schema_id
WHERE execute_as_principal_id IS NOT NULL
ORDER BY schema_name, module_name

If any procedures or functions are returned that are not documented, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79109" severity="medium" conversionstatus="pass" title="SRG-APP-000378-DB-000365" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If the SQL Server instance supports only software development, experimentation and/or developer-level testing (that is, excluding production systems, integration testing, stress testing, and user acceptance testing), this is not a finding. 

Obtain a listing of users and roles who are authorized to create, alter, or replace logic modules from the server documentation.

In each user database, execute the following query:

SELECT P.type_desc AS principal_type, P.name AS principal_name,
O.type_desc,
CASE class
WHEN 0 THEN DB_NAME()
WHEN 1 THEN OBJECT_SCHEMA_NAME(major_id) + '.' + OBJECT_NAME(major_id)
WHEN 3 THEN SCHEMA_NAME(major_id)
ELSE class_desc + '(' + CAST(major_id AS nvarchar) + ')'
END AS securable_name, DP.state_desc, DP.permission_name
FROM sys.database_permissions DP
JOIN sys.database_principals P ON DP.grantee_principal_id = P.principal_id
LEFT OUTER JOIN sys.all_objects O ON O.object_id = DP.major_id AND O.type IN ('TR','TA','P','X','RF','PC','IF','FN','TF','U')
WHERE DP.type IN ('AL','ALTG') AND DP.class IN (0, 1, 53)

SELECT R.name AS role_name, M.type_desc AS principal_type, M.name AS principal_name
FROM sys.database_principals R
JOIN sys.database_role_members DRM ON R.principal_id = DRM.role_principal_id
JOIN sys.database_principals M ON DRM.member_principal_id = M.principal_id
WHERE R.name IN ('db ddladmin','db_owner')
AND M.name != 'dbo'

If any users or role permissions returned are not authorized to modify the specified object or type, this is a finding. 

If any user or role membership is not authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79111" severity="medium" conversionstatus="pass" title="SRG-APP-000380-DB-000360" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Obtain a list of users who have privileged role memberships in the database.

Execute the following query to obtain a list of users and roles and their respective role memberships.

SELECT p.name AS Principal,
  p.type_desc AS Type,
  r.name AS Role
FROM sys.database_principals p
INNER JOIN sys.database_role_members rm ON p.principal_id = rm.member_principal_id
INNER JOIN sys.database_principals r ON rm.role_principal_id = r.principal_id
WHERE r.name = 'db_owner'
UNION ALL
SELECT l.name AS Principal,
 l.type_desc AS Type,
 'dbo' AS Role
FROM sys.databases d
INNER JOIN sys.server_principals l ON d.owner_sid = l.sid
WHERE d.name = DB_NAME()

Review the server documentation to verify the users and roles returned are authorized. 

If any users and/or roles are not documented and authorized, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79113" severity="medium" conversionstatus="pass" title="SRG-APP-000416-DB-000380" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Detailed information on the NIST Cryptographic Module Validation Program (CMVP) is available at the following website: http://csrc.nist.gov/groups/STM/cmvp/index.html.

Review system documentation to determine whether cryptography for classified or sensitive information is required by the information owner.

If the system documentation does not specify the type of information hosted on SQL Server: classified, sensitive, and/or unclassified, this is a finding.

If neither classified nor sensitive information exists within SQL Server databases or configuration, this is not a finding.

Verify that Windows is configured to require the use of FIPS compliant algorithms.

Click Start &gt;&gt; Type "Local Security Policy" &gt;&gt; Press Enter &gt;&gt; Expand "Local Policies" &gt;&gt; Select "Security Options" &gt;&gt; Locate "System Cryptography:  Use FIPS compliant algorithms for encryption, hashing, and signing".

If the Security Setting for this option is "Disabled" this is a finding.

Note: The list of acceptable algorithms: "AES 256" and "Triple DES".

If cryptography is being used by SQL Server, verify that the cryptography is NIST FIPS 140-2 certified by running the following SQL query:

SELECT DISTINCT name, algorithm_desc
FROM sys.symmetric_keys
WHERE key_algorithm NOT IN ('D3','A3')
ORDER BY name

If any items list showing an uncertified NIST FIPS 140-2 algorithm type, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79115" severity="medium" conversionstatus="pass" title="SRG-APP-000428-DB-000386" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review the system documentation to determine whether the organization has defined the information at rest that is to be protected from modification, which must include, at a minimum, PII and classified information. 

If no information is identified as requiring such protection, this is not a finding. 

Review the configuration of SQL Server, Windows, and additional software as relevant. 

If full-disk encryption is required, and Windows or the storage system is not configured for this, this is a finding. 

If database transparent data encryption (TDE) is called for, check whether it is enabled: 

SELECT
DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' 
WHEN 1 THEN 'Unencrypted' 
WHEN 2 THEN 'Encryption in progress' 
WHEN 3 THEN 'Encrypted' 
WHEN 4 THEN 'Key change in progress' 
WHEN 5 THEN 'Decryption in progress' 
WHEN 6 THEN 'Protection change in progress' 
END AS [Encryption State]
FROM sys.dm_database_encryption_keys

For each user database for which encryption is called for and it is marked Unencrypted, this is a finding. 

If table/column encryption and/or a separation between those who own the data (and can view it) and those who manage the data (but should have no access) is required for PII or similar types of data, use Always Encrypted.  The details for configuring Always Encrypted are located here: https://msdn.microsoft.com/en-us/library/mt163865.aspx.

Review the definitions and contents of the relevant tables/columns for the Always Encryption settings, if any of the information defined as requiring cryptographic protection is not encrypted this is a finding.</RawString>
    </Rule>
    <Rule id="V-79117" severity="medium" conversionstatus="pass" title="SRG-APP-000429-DB-000387" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review the system documentation to determine whether the organization has defined the information at rest that is to be protected from disclosure, which must include, at a minimum, PII and classified information. 

If no information is identified as requiring such protection, this is not a finding. 

If full-disk encryption is required, and Windows or the storage system is not configured for this, this is a finding. 

If database transparent data encryption (TDE) is called for, check whether it is enabled: 

SELECT
DB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN 'No database encryption key present, no encryption' 
WHEN 1 THEN 'Unencrypted' 
WHEN 2 THEN 'Encryption in progress' 
WHEN 3 THEN 'Encrypted' 
WHEN 4 THEN 'Key change in progress' 
WHEN 5 THEN 'Decryption in progress' 
WHEN 6 THEN 'Protection change in progress' 
END AS [Encryption State]
FROM sys.dm_database_encryption_keys

For each user database for which encryption is called for and it is marked Unencrypted, this is a finding. 

If table/column encryption and/or a separation between those who own the data (and can view it) and those who manage the data (but should have no access) is required for PII or similar types of data, use Always Encrypted.Â  The details for configuring Always Encrypted are located here: https://msdn.microsoft.com/en-us/library/mt163865.aspx.

Review the definitions and contents of the relevant tables/columns for the Always Encryption settings, if any of the information defined as requiring cryptographic protection is not encrypted this is a finding.</RawString>
    </Rule>
  </DocumentRule>
  <ManualRule dscresourcemodule="None">
    <Rule id="V-79067" severity="high" conversionstatus="pass" title="SRG-APP-000080-DB-000063" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Execute the following query:

SELECT name
FROM sys.database_principals
WHERE type in ('U','G')
AND name LIKE '%$'

If no users are returned, this is not a finding.

If users are returned, determine whether each user is a computer account.

Launch PowerShell.

Execute the following code:

Note: &lt;name&gt; represents the username portion of the user. For example; if the user is "CONTOSO\user1$", the username is "user1".

([ADSISearcher]"(&amp;(!ObjectCategory=Computer)(Name=&lt;name&gt;))").FindAll()

If no account information is returned, this is not a finding.

If account information is returned, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79085" severity="medium" conversionstatus="pass" title="SRG-APP-000231-DB-000154" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>From the query prompt: 

SELECT name 
FROM [master].sys.databases 
WHERE state = 0 

Repeat for each database: 
From the query prompt: 
USE [database name] 
SELECT COUNT(name) 
FROM sys.symmetric_keys s, sys.key_encryptions k 
WHERE s.name = '##MS_DatabaseMasterKey##' 
AND s.symmetric_key_id = k.key_id 
AND k.crypt_type = 'ESKP' 

If the value returned is greater than 0, a Database Master Key exists and is encrypted with a password. 

Review procedures and evidence of password requirements used to encrypt Database Master Keys. 

If the passwords are not required to meet DoD password standards, currently a minimum of 15 characters with at least 1 upper-case character, 1 lower-case character, 1 special character, and 1 numeric character, and at least 8 characters changed from the previous password, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79087" severity="medium" conversionstatus="pass" title="SRG-APP-000231-DB-000154" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If no databases require encryption, this is not a finding. 

From the query prompt: 

SELECT name 
FROM [master].sys.databases 
WHERE is_master_key_encrypted_by_server = 1 
AND owner_sid &lt;&gt; 1 
AND state = 0; 
(Note that this query assumes that the [sa] account is not used as the owner of application databases, in keeping with other STIG guidance. If this is not the case, modify the query accordingly.) 

If no databases are returned by the query, this is not a finding. 

For any databases returned, verify in the System Security Plan that encryption of the Database Master Key using the Service Master Key is acceptable and approved by the Information Owner, and the encrypted data does not require additional protections to deter or detect DBA access. If not approved, this is a finding. 

If approved and additional protections are required, then verify the additional requirements are in place in accordance with the System Security Plan. These may include additional auditing on access of the Database Master Key with alerts or other automated monitoring. 

If the additional requirements are not in place, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79089" severity="medium" conversionstatus="pass" title="SRG-APP-000231-DB-000154" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If the application owner and Authorizing Official have determined that encryption of data at rest is not required, this is not a finding.

Review procedures for, and evidence of backup of the Certificate used for encryption in the System Security Plan. 

If the procedures or evidence does not exist, this is a finding. 

If the procedures do not indicate offline and off-site storage of the Certificate used for encryption, this is a finding. 

If procedures do not indicate access restrictions to the Certificate backup, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79091" severity="low" conversionstatus="pass" title="SRG-APP-000233-DB-000124" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Determine elements of security functionality (lists of permissions, additional authentication information, stored procedures, application specific auditing, etc.) which are being housed inside SQL server.

For any elements found, check SQL Server to determine if these objects or code implementing security functionality are located in a separate security domain, such as a separate database, schema, or table created specifically for security functionality.

Run the following query to list all the user-defined databases:
SELECT Name 
FROM sys.databases 
WHERE database_id &gt; 4 
ORDER BY 1;

Review the database structure to determine where security related functionality is stored. If security-related database objects or code are not kept separate, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79093" severity="medium" conversionstatus="pass" title="SRG-APP-000243-DB-000128" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review the procedures for the refreshing of development/test data from production. Review any scripts or code that exists for the movement of production data to development/test systems, or to any other location or for any other purpose. Verify that copies of production data are not left in unprotected locations. If the code that exists for data movement does not comply with the organization-defined data transfer policy and/or fails to remove any copies of production data from unprotected locations, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79097" severity="medium" conversionstatus="pass" title="SRG-APP-000266-DB-000162" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>Review application behavior and custom database code (stored procedures, triggers), to determine whether error messages contain information beyond what is needed for explaining the issue to general users.

If database error messages contain PII data, sensitive business data, or information useful for identifying the host system or database structure, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79099" severity="medium" conversionstatus="pass" title="SRG-APP-000311-DB-000308" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If security labeling is not required, this is not a finding.

If security labeling requirements have been specified, but neither a third-party solution nor a SQL Server Row-Level security solution is implemented that reliably maintains labels on information in storage, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79101" severity="medium" conversionstatus="pass" title="SRG-APP-000313-DB-000309" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If security labeling is not required, this is not a finding.

If security labeling requirements have been specified, but neither a third-party solution nor a SQL Server Row-Level security solution is implemented that reliably maintains labels on information in process, this is a finding.</RawString>
    </Rule>
    <Rule id="V-79103" severity="medium" conversionstatus="pass" title="SRG-APP-000314-DB-000310" dscresource="None">
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <RawString>If security labeling is not required, this is not a finding.

If security labeling requirements have been specified, but neither a third-party solution nor a SQL Server Row-Level security solution is implemented that reliably maintains labels on information in transmission, this is a finding.</RawString>
    </Rule>
  </ManualRule>
  <PermissionRule dscresourcemodule="AccessControlDsc">
    <Rule id="V-79065" severity="high" conversionstatus="fail" title="SRG-APP-000033-DB-000084" dscresource="">
      <AccessControlEntry />
      <Force>True</Force>
      <IsNullOrEmpty>False</IsNullOrEmpty>
      <OrganizationValueRequired>False</OrganizationValueRequired>
      <OrganizationValueTestString />
      <Path />
      <RawString>Review the system documentation to determine the required levels of protection for securables in the database, by type of user. 

Review the permissions actually in place in the database. 

If the actual permissions do not match the documented requirements, this is a finding.

Use the supplemental file "Database permission assignments to users and roles.sql".</RawString>
    </Rule>
  </PermissionRule>
</DISASTIG>
